pj: Pulling from sswiston/rb_tp
e455cf41eadb: Pulling fs layer
ea63c25b051e: Pulling fs layer
b8f0fd91842f: Pulling fs layer
80ff562f94fd: Pulling fs layer
bb622cd75972: Pulling fs layer
e2448062f8e1: Pulling fs layer
dce213b97634: Pulling fs layer
d9a3b75dfae1: Pulling fs layer
7134a2f88f91: Pulling fs layer
ac568d76705b: Pulling fs layer
1b8ba1965843: Pulling fs layer
df1c790f3860: Pulling fs layer
6b9a70cf77ca: Pulling fs layer
249e48657600: Pulling fs layer
3be144b8ea5f: Pulling fs layer
686b87e56f46: Pulling fs layer
82f0fd4360f2: Pulling fs layer
43c3d1b3cb2e: Pulling fs layer
860cbc328b98: Pulling fs layer
f3be334a02d1: Pulling fs layer
c3e78aaadfe0: Pulling fs layer
6a45fb566c99: Pulling fs layer
2c9e49861318: Pulling fs layer
40600080be97: Pulling fs layer
870ad7dec50b: Pulling fs layer
6f9bb40d2014: Pulling fs layer
4f4fb700ef54: Pulling fs layer
4036fe2c4519: Pulling fs layer
ea694f77e69a: Pulling fs layer
810ec912723d: Pulling fs layer
52f44d478870: Pulling fs layer
83872a80c14c: Pulling fs layer
80ff562f94fd: Waiting
706a5a776fd3: Pulling fs layer
bb622cd75972: Waiting
045d9d6dec0a: Pulling fs layer
e2448062f8e1: Waiting
ad988e0c369b: Pulling fs layer
dce213b97634: Waiting
82f0fd4360f2: Waiting
5e5f43bd0d60: Pulling fs layer
d9a3b75dfae1: Waiting
43c3d1b3cb2e: Waiting
7134a2f88f91: Waiting
860cbc328b98: Waiting
f3be334a02d1: Waiting
a83230eec034: Pulling fs layer
c3e78aaadfe0: Waiting
4036fe2c4519: Waiting
aa34220e412e: Pulling fs layer
6a45fb566c99: Waiting
b98658cdf372: Pulling fs layer
2c9e49861318: Waiting
ea694f77e69a: Waiting
40600080be97: Waiting
fac52cbc995f: Pulling fs layer
870ad7dec50b: Waiting
810ec912723d: Waiting
6b8febe6678e: Pulling fs layer
6f9bb40d2014: Waiting
52f44d478870: Waiting
b4e3e66ca648: Pulling fs layer
4f4fb700ef54: Waiting
2dfafb875384: Pulling fs layer
045d9d6dec0a: Waiting
cbd8dba32301: Pulling fs layer
83872a80c14c: Waiting
ad988e0c369b: Waiting
7389ee5b98db: Pulling fs layer
5e5f43bd0d60: Waiting
706a5a776fd3: Waiting
12d8cbb5b62e: Pulling fs layer
ac568d76705b: Waiting
c0cdad6215b7: Pulling fs layer
1b8ba1965843: Waiting
a67f053877c6: Pulling fs layer
a83230eec034: Waiting
df1c790f3860: Waiting
6b9a70cf77ca: Waiting
aa34220e412e: Waiting
927d3c4615e9: Pulling fs layer
b98658cdf372: Waiting
fac52cbc995f: Waiting
ec5984c59fae: Pulling fs layer
249e48657600: Waiting
686b87e56f46: Waiting
6b8febe6678e: Waiting
3be144b8ea5f: Waiting
b4e3e66ca648: Waiting
c0cdad6215b7: Waiting
2dfafb875384: Waiting
a67f053877c6: Waiting
7389ee5b98db: Waiting
cbd8dba32301: Waiting
927d3c4615e9: Waiting
12d8cbb5b62e: Waiting
ec5984c59fae: Waiting
b8f0fd91842f: Verifying Checksum
b8f0fd91842f: Download complete
e455cf41eadb: Verifying Checksum
e455cf41eadb: Download complete
bb622cd75972: Download complete
ea63c25b051e: Download complete
dce213b97634: Download complete
d9a3b75dfae1: Verifying Checksum
d9a3b75dfae1: Download complete
e455cf41eadb: Pull complete
7134a2f88f91: Verifying Checksum
7134a2f88f91: Download complete
ac568d76705b: Verifying Checksum
ac568d76705b: Download complete
e2448062f8e1: Verifying Checksum
e2448062f8e1: Download complete
df1c790f3860: Download complete
6b9a70cf77ca: Verifying Checksum
6b9a70cf77ca: Download complete
249e48657600: Verifying Checksum
249e48657600: Download complete
1b8ba1965843: Verifying Checksum
1b8ba1965843: Download complete
80ff562f94fd: Verifying Checksum
80ff562f94fd: Download complete
686b87e56f46: Verifying Checksum
686b87e56f46: Download complete
3be144b8ea5f: Verifying Checksum
3be144b8ea5f: Download complete
82f0fd4360f2: Verifying Checksum
82f0fd4360f2: Download complete
43c3d1b3cb2e: Download complete
860cbc328b98: Verifying Checksum
860cbc328b98: Download complete
6a45fb566c99: Download complete
f3be334a02d1: Verifying Checksum
40600080be97: Verifying Checksum
40600080be97: Download complete
2c9e49861318: Download complete
c3e78aaadfe0: Verifying Checksum
c3e78aaadfe0: Download complete
870ad7dec50b: Verifying Checksum
870ad7dec50b: Download complete
4036fe2c4519: Verifying Checksum
4036fe2c4519: Download complete
6f9bb40d2014: Download complete
810ec912723d: Download complete
ea63c25b051e: Pull complete
b8f0fd91842f: Pull complete
80ff562f94fd: Pull complete
4f4fb700ef54: Verifying Checksum
4f4fb700ef54: Download complete
bb622cd75972: Pull complete
83872a80c14c: Verifying Checksum
83872a80c14c: Download complete
52f44d478870: Download complete
045d9d6dec0a: Verifying Checksum
045d9d6dec0a: Download complete
706a5a776fd3: Verifying Checksum
706a5a776fd3: Download complete
ad988e0c369b: Verifying Checksum
ad988e0c369b: Download complete
5e5f43bd0d60: Verifying Checksum
5e5f43bd0d60: Download complete
aa34220e412e: Verifying Checksum
aa34220e412e: Download complete
b98658cdf372: Verifying Checksum
b98658cdf372: Download complete
ea694f77e69a: Verifying Checksum
ea694f77e69a: Download complete
fac52cbc995f: Verifying Checksum
fac52cbc995f: Download complete
e2448062f8e1: Pull complete
dce213b97634: Pull complete
d9a3b75dfae1: Pull complete
7134a2f88f91: Pull complete
ac568d76705b: Pull complete
6b8febe6678e: Verifying Checksum
6b8febe6678e: Download complete
2dfafb875384: Download complete
cbd8dba32301: Verifying Checksum
cbd8dba32301: Download complete
7389ee5b98db: Download complete
b4e3e66ca648: Verifying Checksum
b4e3e66ca648: Download complete
c0cdad6215b7: Verifying Checksum
c0cdad6215b7: Download complete
12d8cbb5b62e: Verifying Checksum
12d8cbb5b62e: Download complete
1b8ba1965843: Pull complete
a67f053877c6: Verifying Checksum
a67f053877c6: Download complete
927d3c4615e9: Verifying Checksum
927d3c4615e9: Download complete
df1c790f3860: Pull complete
ec5984c59fae: Verifying Checksum
ec5984c59fae: Download complete
6b9a70cf77ca: Pull complete
249e48657600: Pull complete
3be144b8ea5f: Pull complete
686b87e56f46: Pull complete
82f0fd4360f2: Pull complete
a83230eec034: Verifying Checksum
a83230eec034: Download complete
43c3d1b3cb2e: Pull complete
860cbc328b98: Pull complete
f3be334a02d1: Pull complete
c3e78aaadfe0: Pull complete
6a45fb566c99: Pull complete
2c9e49861318: Pull complete
40600080be97: Pull complete
870ad7dec50b: Pull complete
6f9bb40d2014: Pull complete
4f4fb700ef54: Pull complete
4036fe2c4519: Pull complete
ea694f77e69a: Pull complete
810ec912723d: Pull complete
52f44d478870: Pull complete
83872a80c14c: Pull complete
706a5a776fd3: Pull complete
045d9d6dec0a: Pull complete
ad988e0c369b: Pull complete
5e5f43bd0d60: Pull complete
a83230eec034: Pull complete
aa34220e412e: Pull complete
b98658cdf372: Pull complete
fac52cbc995f: Pull complete
6b8febe6678e: Pull complete
b4e3e66ca648: Pull complete
2dfafb875384: Pull complete
cbd8dba32301: Pull complete
7389ee5b98db: Pull complete
12d8cbb5b62e: Pull complete
c0cdad6215b7: Pull complete
a67f053877c6: Pull complete
927d3c4615e9: Pull complete
ec5984c59fae: Pull complete
Digest: sha256:e849496dd68b3ce2754532044c538a6d681b23b262977f6a2da8deb3a9e6bf90
Status: Downloaded newer image for sswiston/rb_tp:pj
docker.io/sswiston/rb_tp:pj
Setting up Docker container
Performing simulation 320
2024-01-16_18:31:56
Generating PhyloJunction script

RevBayes version (1.2.1)
Build from hawaii_fix (rapture-2191-gf38548) on Fri Jan 12 23:23:51 UTC 2024

Visit the website www.RevBayes.com for more information about RevBayes.

RevBayes is free software released under the GPL license, version 3. Type 'license()' for details.

To quit RevBayes type 'quit()' or 'q()'.


>    Processing file "/storage1/fs1/michael.landis/Active/hawaiian_simulations/scripts/rev_scripts/make_fig_make_pj_exp1.Rev"
   Processing file "scripts/rev_scripts/model.Rev"
Reading features in time slice 1
Reading features in time slice 2
Reading features in time slice 3
Reading features in time slice 4
Reading features in time slice 5
Reading features in time slice 6
Reading features in time slice 7
   Processing of file "scripts/rev_scripts/model.Rev" completed

Preparing .pj script string for sample 320

Whole tree root age = 22.9803
Origin age of island radiation = 13.9055
Island that got colonized = Necker
    Doing time slice 1
      Doing extinction rates
      Doing transition rates
      Doing birth rates
    Doing time slice 2
      Doing extinction rates
      Doing transition rates
      Doing birth rates
    Doing time slice 3
      Doing extinction rates
      Doing transition rates
      Doing birth rates
    Doing time slice 4
      Doing extinction rates
      Doing transition rates
      Doing birth rates
    Doing time slice 5
      Doing extinction rates
      Doing transition rates
      Doing birth rates
    Doing time slice 6
      Doing extinction rates
      Doing transition rates
      Doing birth rates
    Doing time slice 7
      Doing extinction rates
      Doing transition rates
      Doing birth rates
Running PhyloJunction script
Matplotlib created a temporary cache directory at /tmp/458757.tmpdir/matplotlib-84vi8uvs because the default path (/home/k.swiston/.config/matplotlib) is not a writable directory; it is highly recommended to set the MPLCONFIGDIR environment variable to a writable directory, in particular to speed up the import of Matplotlib and to better support multiprocessing.
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:456: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise in a future error of pandas. Value '13.7274' has dtype incompatible with float64, please explicitly cast to a compatible dtype first.
  tree_summary_df_dict[rv_name].at[idx, "root_age"] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:460: FutureWarning: Setting an item of incompatible dtype is deprecated and will raise in a future error of pandas. Value '13.9055' has dtype incompatible with float64, please explicitly cast to a compatible dtype first.
  tree_summary_df_dict[rv_name].at[idx, "origin_age"] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
/PhyloJunction/src/phylojunction/readwrite/pj_write.py:480: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  tree_summary_df_dict[rv_name].at[idx, "n_" + str(ith_state)] = \
Reading script /storage1/fs1/michael.landis/Active/hawaiian_simulations/experiment1/pj_scripts/sim320.pj
    ... done!
outfile_path = /storage1/fs1/michael.landis/Active/hawaiian_simulations/experiment1/pj_output/figures/sample320_trs1_1
Traceback (most recent call last):
  File "/.local/bin/pjcli", line 33, in <module>
    sys.exit(load_entry_point('phylojunction', 'console_scripts', 'pjcli')())
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/PhyloJunction/src/phylojunction/interface/pjcli/pj_cli.py", line 156, in call_cli
    execute_pj_script(
  File "/PhyloJunction/src/phylojunction/interface/pjcli/pj_cli.py", line 83, in execute_pj_script
    cliplt.call_node_plot_cli(
  File "/PhyloJunction/src/phylojunction/interface/pjcli/cli_plotting.py", line 139, in call_node_plot_cli
    selected_node_plot_cli(
  File "/PhyloJunction/src/phylojunction/interface/pjcli/cli_plotting.py", line 78, in selected_node_plot_cli
    node_pgm.plot_node(
  File "/PhyloJunction/src/phylojunction/pgm/pgm.py", line 567, in plot_node
    .plot_node(axes, node_attr=branch_attr)
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/PhyloJunction/src/phylojunction/data/tree.py", line 1035, in plot_node
    return plot_ann_tree(self, axes, attr_of_interest=node_attr)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/PhyloJunction/src/phylojunction/data/tree.py", line 1571, in plot_ann_tree
    color = color_map[attr_idx]
            ~~~~~~~~~^^^^^^^^^^
KeyError: 23

RevBayes version (1.2.1)
Build from hawaii_fix (rapture-2191-gf38548) on Fri Jan 12 23:23:51 UTC 2024

Visit the website www.RevBayes.com for more information about RevBayes.

RevBayes is free software released under the GPL license, version 3. Type 'license()' for details.

To quit RevBayes type 'quit()' or 'q()'.


>    Processing file "/storage1/fs1/michael.landis/Active/hawaiian_simulations/scripts/rev_scripts/sim_sequences.Rev"
Working on simulation 320
root age 22.9803 colonization age 13.9055 origin time 0.178116 ingroup branch 9.25292
Got root and colonization ages
Grafted outgroup onto tree
Grafted outgroup onto tip data
   Attempting to read the contents of file "sample320.tre"
   Successfully read file
Removed extinct taxa and saved new tree
Simulated sequences

------------------------------------------------------------
Sender: LSF System <lsfadmin@compute1-exec-92.ris.wustl.edu>
Subject: Job 458757: <320> in cluster <compute1-lsf> Done

Job <320> was submitted from host <compute1-client-1.ris.wustl.edu> by user <k.swiston> in cluster <compute1-lsf> at Tue Jan 16 12:30:00 2024
Job was executed on host(s) <compute1-exec-92.ris.wustl.edu>, in queue <general>, as user <k.swiston> in cluster <compute1-lsf> at Tue Jan 16 12:30:03 2024
</home/k.swiston> was used as the home directory.
</storage1/fs1/michael.landis/Active/hawaiian_simulations/> was used as the working directory.
Started at Tue Jan 16 12:30:03 2024
Terminated at Tue Jan 16 16:56:54 2024
Results reported at Tue Jan 16 16:56:54 2024

Your job looked like:

------------------------------------------------------------
# LSBATCH: User input
/bin/bash /storage1/fs1/michael.landis/Active/hawaiian_simulations/scripts/sim.sh
------------------------------------------------------------

Successfully completed.

Resource usage summary:

    CPU time :                                   17.20 sec.
    Max Memory :                                 25 MB
    Average Memory :                             9.04 MB
    Total Requested Memory :                     4096.00 MB
    Delta Memory :                               4071.00 MB
    Max Swap :                                   -
    Max Processes :                              8
    Max Threads :                                34
    Run time :                                   16011 sec.
    Turnaround time :                            16014 sec.

The output (if any) is above this job summary.

