##### THIS SCRIPT IS STILL IN PROGRESS AND DOES NOT WORK YET #####

# setup
seed(s_idx)

# reading tree
tree_fp = exp_path + "sim_data/" + "sample" + s_idx + ".tre"
phy = readTrees(file=tree_fp)[1]
tree_height  <- phy.rootAge()
taxa         = phy.taxa()
num_taxa     = taxa.size()
num_branches = 2 * num_taxa - 2

# reading molecular data
mol_fp = exp_path + "sim_data/" + "sample" + s_idx + ".sequences.nex"
dat_mol = readDiscreteCharacterData(mol_fp)
num_sites = dat_mol.nchar()

# reading range data
bg_fp = exp_path + "sim_data/" + "sample" + s_idx + ".data.tsv"
dat_01 <- readCharacterDataDelimited( bg_fp,
                                   type="NaturalNumbers",
                                   stateLabels=63,
                                   delimiter="\t",
                                   header=false )
print(dat_01.show())
print(dat_01.nchar())
dat_nn = formatDiscreteCharacterData(dat_01, format="GeoSSE", numStates=63)

# tree model
#timetree ~ dnGLHBDSP( rootAge      = root_age,
#                          lambda       = lambda,
#                          mu           = mu,
#                          eta          = Q_bg,
#                          omega        = omega,
#                          lambdaTimes  = times,
#                          muTimes      = times,
#                          etaTimes     = times,
#                          omegaTimes   = times,
#                          rhoTimes     = rho_times,
#                          pi           = pi_bg,
#                          rho          = rho_sample,
#                          condition    = condition,
#                          taxa         = taxa,
#                          nStates      = num_ranges,
#                          nProc        = n_proc )

# molecular model
#mu_mol_base ~ dnLoguniform(5e-4, 5e-2)
#Q <- fnJC(4)
#mu_mol_sd <- 0.587405 
#if (exists("mu_mol_branch")) {clear(mu_mol_branch)}
#for (j in 1:num_branches) {
#    ln_mean := ln(mu_mol_base) - 0.5 * mu_mol_sd * mu_mol_sd
#    mu_mol_branch[j] ~ dnLnorm(ln_mean, mu_mol_sd)
#}   
#seq ~ dnPhyloCTMC(tree=phy,Q=Q,branchRates=mu_mol_branch,nSites=2000,type="DNA")

# clamping data
#timetree.setValue(phy)
#timetree.clampCharData(dat_nn)
#seq.clamp(dat_mol)

# setting up MCMC
#print("Compute Tensorphylo model probability...")
#timetree.lnProbability()
#print("...done!")

# creating moves
#print("Creating moves...")
#moves = VectorMoves()

# tree variable moves
#if (update_topology) {
#    moves.append( mvNNI(timetree, weight=num_taxa) )
#    moves.append( mvFNPR(timetree, weight=num_taxa/4) )
#}
#moves.append( mvNodeTimeSlideUniform(timetree, weight=num_taxa) )
#moves.append( mvScale(root_age, weight=10) )

#for (i in 1:sigma_e.size()) {
#    moves.append( mvScale(sigma_e[i], weight=2) )
#    moves.append( mvScale(sigma_w[i], weight=2) )
#    moves.append( mvSlide(sigma_e[i], weight=2) )
#    moves.append( mvSlide(sigma_w[i], weight=2) )
#    if (use_rj) {
#        moves.append( mvRJSwitch(sigma_e[i], weight=3) )
#        moves.append( mvRJSwitch(sigma_w[i], weight=3) )
#        use_sigma_e[i] := ifelse(sigma_e[i] == 0.0, 0, 1)
#        use_sigma_w[i] := ifelse(sigma_w[i] == 0.0, 0, 1)
#    }
#}
#for (i in 1:sigma_d.size()) {
#    moves.append( mvScale(sigma_d[i], weight=2) )
#    moves.append( mvScale(sigma_b[i], weight=2) )
#    moves.append( mvSlide(sigma_d[i], weight=2) )
#    moves.append( mvSlide(sigma_b[i], weight=2) )
#    if (use_rj) {
#        moves.append( mvRJSwitch(sigma_d[i], weight=3) )
#        moves.append( mvRJSwitch(sigma_b[i], weight=3) )
#        use_sigma_d[i] := ifelse(sigma_d[i] == 0.0, 0, 1)
#        use_sigma_b[i] := ifelse(sigma_b[i] == 0.0, 0, 1)
#    }
#}
#for (i in 1:phi_e.size()) {
#    moves.append( mvScale(phi_e[i], weight=2) )
#    moves.append( mvScale(phi_w[i], weight=2) )
#    moves.append( mvSlide(phi_e[i], weight=2) )
#    moves.append( mvSlide(phi_w[i], weight=2) )
#    if (use_rj) {
#        moves.append( mvRJSwitch(phi_e[i], weight=3) )
#        moves.append( mvRJSwitch(phi_w[i], weight=3) )
#        use_phi_e[i] := ifelse(phi_e[i] == 0.0, 0, 1)
#        use_phi_w[i] := ifelse(phi_w[i] == 0.0, 0, 1)
#    }
#}
#for (i in 1:phi_d.size()) {
#    moves.append( mvScale(phi_d[i], weight=2) )
#    moves.append( mvScale(phi_b[i], weight=2) )
#    moves.append( mvSlide(phi_d[i], weight=2) )
#    moves.append( mvSlide(phi_b[i], weight=2) )   
#    if (use_rj) {
#        moves.append( mvRJSwitch(phi_d[i], weight=3) )
#        moves.append( mvRJSwitch(phi_b[i], weight=3) )
#        use_phi_d[i] := ifelse(phi_d[i] == 0.0, 0, 1)
#        use_phi_b[i] := ifelse(phi_b[i] == 0.0, 0, 1)
#    }
#}

# molecular moves
# base rate of molecular substitution
#moves.append(mvScale(mu_mol_base, weight=5) )

# branch rates of molecular substitution, centered on mu_mol_base
#for (i in 1:num_branches) {
#    moves.append(mvScale(mu_mol_branch[i], weight=1))
#}

#for (i in 1:num_loci) {
#    if (i >= 2) {
#        moves.append(mvScale(mu_mol_locus_rel[i], weight=3))
#    }
#    moves.append(mvScale(kappa[i], weight=3))
#    moves.append(mvScale(alpha[i], weight=3))
#    moves.append(mvSimplex(pi_mol[i], alpha=3, offset=0.5, weight=3))
#}

# joint moves
#up_down_scale_tree = mvUpDownScale(lambda=1.0, weight=20)
#up_down_scale_tree.addVariable(timetree,      up=true)
#up_down_scale_tree.addVariable(root_age,      up=true)
#up_down_scale_tree.addVariable(mu_mol_branch, up=false)
#up_down_scale_tree.addVariable(mu_mol_base,   up=false)
#moves.append(up_down_scale_tree)

#up_down_mol_rate = mvUpDownScale(lambda=1.0, weight=20)
#up_down_mol_rate.addVariable(mu_mol_branch, up=true)
#up_down_mol_rate.addVariable(mu_mol_base,   up=true)
#moves.append(up_down_mol_rate)

# MJL: this seems to cause a bug, working to fix w/ Mike May
#rate_age_proposal = mvRateAgeProposal(timetree, weight=20, alpha=5)
#rate_age_proposal.addRates(mu_mol_branch)
#moves.append(rate_age_proposal)

# creating monitors
#print("Creating monitors...")
# create monitor vector
#monitors = VectorMonitors()
# screen monitor, so you don't get bored
#monitors.append( mnScreen(root_age, printgen=print_gen) )
# file monitor for all simple model variables
#monitors.append( mnModel(printgen=print_gen, file="output/" + analysis + ".model.txt") )
# file monitor for tree
#monitors.append( mnFile(timetree, printgen=print_gen, file="output/" + analysis + ".tre") )
# file monitor for molecular model
#monitors.append( mnFile(mu_mol_base, mu_mol_branch, mu_mol_locus_rel, alpha, kappa, root_age, printgen=print_gen, file="output/" + analysis + ".mol.txt") )
# file monitor for biogeographic model
#for (k in 1:num_times) {
#    bg_mon_filename = "output/" + analysis + ".time" + k + ".bg.txt"
#    monitors.append( mnFile(filename = bg_mon_filename,printgen=print_gen,rho_e, rho_w, rho_d, rho_b, r_e[k], r_w[k], r_d[k][1], r_d[k][2], r_d[k][3], r_d[k][4], r_d[k][5], r_d[k][6], r_b[k][1], r_b[k][2], r_b[k][3], r_b[k][4], r_b[k][5], r_b[k][6], m_e[k][1], m_w[k][1], m_d[k][1], m_d[k][2], m_d[k][3], m_d[k][4], m_d[k][5], m_d[k][6], m_b[k][1], m_b[k][2], m_b[k][3], m_b[k][4], m_b[k][5], m_b[k][6]))
#}

# ancestral estimates
#monitors.append( mnJointConditionalAncestralState(tree=timetree, glhbdsp=timetree, printgen=print_gen*stoch_print_gen, filename="output/" + analysis + ".states.txt", withTips=true, withStartStates=true, type="NaturalNumbers") ) 

#monitors.append( mnStochasticCharacterMap(glhbdsp=timetree, printgen=print_gen*10, filename="output/" + analysis + ".stoch.txt", use_simmap_default=false) )
# report any other summary statistics

# create model object
#print("Creating model...")
#mymodel = model(timetree)

# create MCMC object
#print("Creating MCMC...")
#mymcmc = mcmc(mymodel, moves, monitors, moveschedule=move_schedule)
#mymcmc.operatorSummary()

# run MCMC
#print("Running MCMC...")
#mymcmc.run(n_iter, underPrior=under_prior)

# done!
quit()
