##### THIS SCRIPT IS STILL IN PROGRESS AND DOES NOT WORK YET #####

if (!exists("s_idx")) s_idx = 9999 #101
if (!exists("exp_path")) exp_path = "./experiment1/"

# load core model
source("scripts/rev_scripts/model.Rev")

# setup
seed(s_idx)

# analysis settings
n_proc <- 4
print_gen <- 10
n_iter <- 5000
under_prior = false
move_schedule = v("single","random")[1]
update_topology = false
analysis = "sim_" + s_idx

# reading tree
tree_fp      = exp_path + "sim_data/sample" + s_idx + ".tre"
phy          = readTrees(file=tree_fp)[1]
tree_height  <- phy.rootAge()
taxa         = phy.taxa()
num_taxa     = taxa.size()
num_branches = 2 * num_taxa - 2

# reading molecular data
mol_fp    = exp_path + "sim_data/" + "sample" + s_idx + ".sequences.nex"
dat_mol   = readDiscreteCharacterData(mol_fp)
num_sites = dat_mol.nchar()

# reading range data
bg_fp = exp_path + "sim_data/" + "sample" + s_idx + ".data.tsv"
num_regions <- 7  # TODO: possibly learn this from regional feature files
num_states <- floor(2^num_regions - 1)
dat_nn <- readCharacterDataDelimited( bg_fp,
                                      type="NaturalNumbers",
                                      stateLabels=num_states,
                                      delimiter=",",
                                      header=false )

# We might not need the next command because the RevBayes script will output ranges in
# natural number encoding (not bit-vector encoding).
# Uncomment to test (will segfault)
#dat_nn = formatDiscreteCharacterData(dat_01, format="GeoSSE", numStates=100)

# tree model
whole_tree_age ~ dnUniform(0,30)
whole_tree_age.setValue(tree_height)

# expected number of taxa
outgroup_region     <- 7
outgroup_birth_rate <- rho_w * m_w[1][1][outgroup_region]
outgroup_death_rate <- rho_e * m_e[1][1][outgroup_region]
n_expected_outgroup_taxa <- 2 * exp((outgroup_birth_rate - outgroup_death_rate) * tree_height)
rho_outgroup <- Probability(1.0 / n_expected_outgroup_taxa)

# rho sample
for (i in 1:num_states) {
    rho_sample[1][i] <- 1.0
}
rho_sample[1][outgroup_region] <- rho_outgroup
rho_times <- [ 0.0 ]

# root state frequencies
for (i in 1:num_states) {
    pi_root_region_vec[i] <- 0.0
}
pi_root_region_vec[outgroup_region] <- 1.0
pi_root_region <- simplex(pi_root_region_vec)

# convert RevBayes epoch times (descending order) into Tensorphylo
# epoch times (ascending order)
for (i in 1:times.size()) {
    j <- times.size() - i + 1
    reverse_times[j] <- times[i]
}

# set up Tensorphylo SSE model
condition="survival"
timetree ~ dnGLHBDSP( rootAge          = whole_tree_age,
                          lambda       = lambda,
                          mu           = mu,
                          eta          = Q,
                          omega        = omega,
                          pi           = pi_root_region,
                          lambdaTimes  = times,
                          muTimes      = times,
                          etaTimes     = times,
                          omegaTimes   = times,
                          rho          = rho_sample,
                          rhoTimes     = rho_times,
                          condition    = condition,
                          taxa         = taxa,
                          nStates      = num_states,
                          nProc        = n_proc )



# molecular model
mu_mol_base ~ dnLoguniform(5e-4, 5e-2)
Q_mol <- fnJC(4)
mu_mol_sd <- 0.587405 
#if (exists("mu_mol_branch")) {clear(mu_mol_branch)}
for (j in 1:num_branches) {
    ln_mean := ln(mu_mol_base) - 0.5 * mu_mol_sd * mu_mol_sd
    mu_mol_branch[j] ~ dnLnorm(ln_mean, mu_mol_sd)
}   
seq ~ dnPhyloCTMC(tree=timetree,
                  Q=Q_mol,
                  branchRates=mu_mol_branch,
                  nSites=2000,type="DNA")

# clamping data
timetree.clamp(phy)
timetree.clampCharData(dat_nn)
seq.clamp(dat_mol)

# setting up MCMC
print("Compute Tensorphylo model probability...")
timetree.lnProbability()
print("...done!")

# creating moves
print("Creating moves...")
moves = VectorMoves()

# tree variable moves
if (update_topology) {
    moves.append( mvNNI(timetree, weight=num_taxa) )
    moves.append( mvFNPR(timetree, weight=num_taxa/4) )
}
moves.append( mvNodeTimeSlideUniform(timetree, weight=num_taxa) )
moves.append( mvScale(whole_tree_age, weight=10) )

for (i in 1:sigma_e.size()) {
    moves.append( mvScale(sigma_e[i], weight=2) )
    moves.append( mvScale(sigma_w[i], weight=2) )
    moves.append( mvSlide(sigma_e[i], weight=2) )
    moves.append( mvSlide(sigma_w[i], weight=2) )
    if (use_rj) {
        moves.append( mvRJSwitch(sigma_e[i], weight=3) )
        moves.append( mvRJSwitch(sigma_w[i], weight=3) )
        use_sigma_e[i] := ifelse(sigma_e[i] == 0.0, 0, 1)
        use_sigma_w[i] := ifelse(sigma_w[i] == 0.0, 0, 1)
    }
}
for (i in 1:sigma_d.size()) {
    moves.append( mvScale(sigma_d[i], weight=2) )
    moves.append( mvScale(sigma_b[i], weight=2) )
    moves.append( mvSlide(sigma_d[i], weight=2) )
    moves.append( mvSlide(sigma_b[i], weight=2) )
    if (use_rj) {
        moves.append( mvRJSwitch(sigma_d[i], weight=3) )
        moves.append( mvRJSwitch(sigma_b[i], weight=3) )
        use_sigma_d[i] := ifelse(sigma_d[i] == 0.0, 0, 1)
        use_sigma_b[i] := ifelse(sigma_b[i] == 0.0, 0, 1)
    }
}
for (i in 1:phi_e.size()) {
    moves.append( mvScale(phi_e[i], weight=2) )
    moves.append( mvScale(phi_w[i], weight=2) )
    moves.append( mvSlide(phi_e[i], weight=2) )
    moves.append( mvSlide(phi_w[i], weight=2) )
    if (use_rj) {
        moves.append( mvRJSwitch(phi_e[i], weight=3) )
        moves.append( mvRJSwitch(phi_w[i], weight=3) )
        use_phi_e[i] := ifelse(phi_e[i] == 0.0, 0, 1)
        use_phi_w[i] := ifelse(phi_w[i] == 0.0, 0, 1)
    }
}
for (i in 1:phi_d.size()) {
    moves.append( mvScale(phi_d[i], weight=2) )
    moves.append( mvScale(phi_b[i], weight=2) )
    moves.append( mvSlide(phi_d[i], weight=2) )
    moves.append( mvSlide(phi_b[i], weight=2) )   
    if (use_rj) {
        moves.append( mvRJSwitch(phi_d[i], weight=3) )
        moves.append( mvRJSwitch(phi_b[i], weight=3) )
        use_phi_d[i] := ifelse(phi_d[i] == 0.0, 0, 1)
        use_phi_b[i] := ifelse(phi_b[i] == 0.0, 0, 1)
    }
}

# molecular moves
# base rate of molecular substitution
moves.append(mvScale(mu_mol_base, weight=5) )

# branch rates of molecular substitution, centered on mu_mol_base
for (i in 1:num_branches) {
    moves.append(mvScale(mu_mol_branch[i], weight=1))
}

#for (i in 1:num_loci) {
#    if (i >= 2) {
#        moves.append(mvScale(mu_mol_locus_rel[i], weight=3))
#    }
#    moves.append(mvScale(kappa[i], weight=3))
#    moves.append(mvScale(alpha[i], weight=3))
#    moves.append(mvSimplex(pi_mol[i], alpha=3, offset=0.5, weight=3))
#}

# joint moves
up_down_scale_tree = mvUpDownScale(lambda=1.0, weight=20)
up_down_scale_tree.addVariable(timetree,      up=true)
up_down_scale_tree.addVariable(whole_tree_age,      up=true)
up_down_scale_tree.addVariable(mu_mol_branch, up=false)
up_down_scale_tree.addVariable(mu_mol_base,   up=false)
moves.append(up_down_scale_tree)

up_down_mol_rate = mvUpDownScale(lambda=1.0, weight=20)
up_down_mol_rate.addVariable(mu_mol_branch, up=true)
up_down_mol_rate.addVariable(mu_mol_base,   up=true)
moves.append(up_down_mol_rate)

# MJL: this seems to cause a bug, working to fix w/ Mike May
#rate_age_proposal = mvRateAgeProposal(timetree, weight=20, alpha=5)
#rate_age_proposal.addRates(mu_mol_branch)
#moves.append(rate_age_proposal)

# creating monitors
#print("Creating monitors...")
# create monitor vector
monitors = VectorMonitors()
# screen monitor, so you don't get bored
monitors.append( mnScreen(whole_tree_age, printgen=print_gen) )
# file monitor for all simple model variables
monitors.append( mnModel(printgen=print_gen, file="output/" + analysis + ".model.txt") )
# file monitor for tree
monitors.append( mnFile(timetree, printgen=print_gen, file="output/" + analysis + ".tre") )
# file monitor for molecular model
monitors.append( mnFile(mu_mol_base, mu_mol_branch, whole_tree_age, printgen=print_gen, file="output/" + analysis + ".mol.txt") )
# file monitor for biogeographic model
#for (k in 1:num_times) {
#    bg_mon_filename = "output/" + analysis + ".time" + k + ".bg.txt"
#    monitors.append( mnFile(filename = bg_mon_filename,printgen=print_gen,rho_e, rho_w, rho_d, rho_b, r_e[k], r_w[k], r_d[k][1], r_d[k][2], r_d[k][3], r_d[k][4], r_d[k][5], r_d[k][6], r_b[k][1], r_b[k][2], r_b[k][3], r_b[k][4], r_b[k][5], r_b[k][6], m_e[k][1], m_w[k][1], m_d[k][1], m_d[k][2], m_d[k][3], m_d[k][4], m_d[k][5], m_d[k][6], m_b[k][1], m_b[k][2], m_b[k][3], m_b[k][4], m_b[k][5], m_b[k][6]))
#}

# ancestral estimates
#monitors.append( mnJointConditionalAncestralState(tree=timetree, glhbdsp=timetree, printgen=print_gen*stoch_print_gen, filename="output/" + analysis + ".states.txt", withTips=true, withStartStates=true, type="NaturalNumbers") ) 

#monitors.append( mnStochasticCharacterMap(glhbdsp=timetree, printgen=print_gen*10, filename="output/" + analysis + ".stoch.txt", use_simmap_default=false) )
# report any other summary statistics

# create model object
print("Creating model...")
mymodel = model(timetree)

# create MCMC object
print("Creating MCMC...")
mymcmc = mcmc(mymodel, moves, monitors, moveschedule=move_schedule)
mymcmc.operatorSummary()

# run MCMC
print("Running MCMC...")
mymcmc.run(n_iter, underPrior=under_prior)

# done!
quit()
